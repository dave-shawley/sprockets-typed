{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"User's Guide","text":""},{"location":"#overview","title":"Overview","text":"<p>Static type analysis is a great way to catch bugs. It is also a great way to inform editors, AI assistants, and other tools about the contracts within your code. This library started out as a way to improve the docuemntation of Tornado web applications with hopes of being able to keep OpenAPI specifications up to date in addition to providing type safety inside the codebase.</p> <pre><code>import uuid\n\nimport pydantic\nimport sprockets_typed\nfrom tornado import web\n\nclass CreateItemRequest(pydantic.BaseModel):\n    name: str\n    description: str\n\nclass Item(CreateItemRequest):\n    id: uuid.UUID\n\nclass CreateItemHandler(sprockets_typed.RequestHandler,\n                        web.RequestHandler):\n    async def post(self) -&gt; None:\n        request = self.get_request_as(CreateItemRequest)\n        item = await self.create_item(request)\n        self.send_response(item)\n\n    async def create_item(self, request: CreateItemRequest) -&gt; Item:\n        ...\n\nclass ItemHandler(sprockets_typed.RequestHandler,\n                  web.RequestHandler):\n    async def get(self, **_: object) -&gt; None:\n        item_id = self.get_path_argument('item_id', uuid.UUID)\n        item = await self.get_item(item_id)\n        if item is None:\n            self.send_error(404)\n        else:\n            self.send_response(item)\n\n    async def get_item(self, item_id: uuid.UUID) -&gt; Item:\n        ...\n</code></pre>"},{"location":"#key-functions","title":"Key functions","text":""},{"location":"#get_request_asmodel_cls","title":"get_request_as(model_cls)","text":"<p>Deserialize the request body as the given model. This will raise <code>exceptions.RequestValidationError</code> when the request body cannot be deserialized as <code>model_cls</code>. The status code is set to \"415 Unsupported Media Type\" if the content type is not supported and \"422 Unprocessable Entity\" if the request body does not match the model schema.</p>"},{"location":"#send_responseresponse","title":"send_response(response)","text":""},{"location":"#get_path_argumentname-coerce_to","title":"get_path_argument(name, coerce_to)","text":""},{"location":"#get_query_argumentname-coerce_to-default","title":"get_query_argument(name:, coerce_to, default)","text":""},{"location":"changelog/","title":"Release history","text":""},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li><code>TypedRequestHandler.get_request_as</code></li> </ul>"},{"location":"reference/","title":"API Reference","text":""},{"location":"reference/#sprockets_typed.TypedRequestHandler","title":"<code>sprockets_typed.TypedRequestHandler</code>","text":"<p>               Bases: <code>RequestHandler</code></p> <p>Handles HTTP requests with deserialization and validation support.</p> <p>This class is designed to extend Tornado's web.RequestHandler by adding convenient methods for deserializing incoming request bodies and validating them against specified types. It supports multiple content types, including JSON, and leverages the flexibility of pydantic for type validation.</p>"},{"location":"reference/#sprockets_typed.TypedRequestHandler.__deserialize_with_tornado","title":"<code>__deserialize_with_tornado</code>","text":"<p>Deserialize with tornado.httputil</p> <p>Returns: <code>None</code> if no deserialization was possible.</p>"},{"location":"reference/#sprockets_typed.TypedRequestHandler.get_request_as","title":"<code>get_request_as</code>","text":"<p>Deserialize and validate the request body.</p> <p>Deserializes the body of the request and validates it against the provided type. The method ensures that the request body is properly validated or raises an error if it cannot be validated or is incompatible with the specified type.</p> <p>Parameters:</p> <ul> <li> <code>body_cls</code>               (<code>type[get_request_as[T]]</code>)           \u2013            <p>The target class type to which the body should be validated. Can be a subclass of pydantic.BaseModel or any other type.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>get_request_as[T] | None</code>           \u2013            <p>The deserialized and validated request body of the specified type, or None if the target class type is NoneType and the body is empty.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RequestValidationError</code>             \u2013            <p>If the body cannot be deserialized, validated, or does not match the specified class type.</p> </li> </ul>"},{"location":"reference/#sprockets_typed.RequestValidationError","title":"<code>sprockets_typed.RequestValidationError</code>","text":"<p>               Bases: <code>HTTPError</code></p> <p>Raised when a request fails validation.</p>"}]}